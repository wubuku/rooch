# README

English | [中文](README_CN.md)

This article mainly introduces how to use a low-code tool to develop a blog sample application.

## Prerequisites

Currently, the dddappp low-code tool is published as a Docker image for developers to experience.

The off-chain services generated by the tool use Java language and use MySQL database by default. But this article does not intend to explain in detail the deployment and testing of the off-chain services, but mainly introduces how to use Rooch CLI and jq and other command-line tools to query the on-chain state and test contracts.

So before you start experiencing, you need to:

* Install [Rooch CLI](https://github.com/rooch-network/rooch).

* Install [Docker](https://docs.docker.com/engine/install/).

* Install `curl` and `jp` commands (jp - commandline JSON processor). We can use `jp` to process JSON RPC returned JSON results when testing contracts.

* (Optional) Install MySQL database. Can be used to deploy and test off-chain services.

* (Optional) Install JDK and Maven. Used to build and test off-chain services.

## Programing

You can follow the introduction below to reproduce the "programming" process of this sample application. You will find that to develop a complete application, you only need to write very little code. If your application's business logic is just simple CRUD operations on some entities, then you may not even need to write any code other than the "model".

### Write DDDML Model Files 

The low-code dddappp tool we introduced relies on the domain model described by DDDML (Domain-Driven Design Modeling Language) to generate various parts of the application code.

> **Tip**
>
> About DDDML, here is an introductory article: [“Introducing DDDML: The Key to Low-Code Development for Decentralized Applications”](https://github.com/wubuku/Dapp-LCDP-Demo/blob/main/IntroducingDDDML.md). This article contains detailed explanations of some more complex DDDML sample model files.

You can create a directory, for example, named `test`, to place all the application code, and then create a subdirectory `dddml` within this directory. We usually place the model files written according to the DDDML specification in this directory.

Create a plain text file in the `dddml` directory, named `blog.yaml`, with the following content:

```yaml
aggregates:
  Article:
    metadata:
      Preprocessors: ["MOVE_CRUD_IT"]
    id:
      name: Id
      type: ObjectID

    properties:
      Title:
        type: String
        length: 200
      Body:
        type: String
        length: 2000
      Comments:
        itemType: Comment

    entities:
      Comment:
        metadata:
          Preprocessors: ["MOVE_CRUD_IT"]
        id:
          name: CommentSeqId
          type: u64
        properties:
          Commenter:
            type: String
            length: 100
          Body:
            type: String
            length: 500
```

The meaning of this DDDML model should be very clear to developers, but we will still explain it briefly below.

This code defines an aggregate named `Article` and a same-named aggregate root entity, as well as an aggregate internal entity named `Comment`.

Experienced developers should already understand the concept of “entity”.

If you are not very familiar with the DDD concepts of “aggregate”, “aggregate root”, etc., it does not matter. You can first understand the aggregate as “a collection of closely related aggregate root entity and aggregate internal entities”, and understand that “the relationship between the aggregate root and the aggregate internal entities is ‘I own you’”, that's it.

#### "Article" Aggregate

Under the key node `/aggregates/Article/metadata`, we define some metadata to indicate some preprocessors that should be applied when generating code. Here we use the `MOVE_CRUD_IT` preprocessor, which automatically implements the CRUD operation logic for entities.

Under the key node `/aggregates/Article/id`, we define the ID of the article aggregate root. The name of the article ID is `Id`, and the type is `ObjectID`. Here `ObjectID` is a platform-specific type, and we assume that we are developing a decentralized application based on Rooch.

Under the key node `/aggregates/Article/properties`, we define the properties of the article, which represent the title, body, and comments of the article.

The `Title` property of the article is a property of type String with a length limit of 200 characters.

The `Body` property of the article is a property of type String with a length limit of 2000 characters.

The `Comments` property of the article is a collection (`itemType: Comment`) of elements of type `Comment`. Here `Comment` is an internal entity of the aggregate.

#### "Comment" Entity

Under the key node `/aggregates/Article/entities/Comment`, we define the "comment" internal entity of the aggregate.

The `id` of the comment (aggregate internal entity) defined here is a local ID, which only needs to ensure that this ID value is unique among different comments within the same article.

We name the comment ID as `CommentSeqId` and declare its type as `u64`.

Under the key node `/aggregates/Article/entities/Comment/metadata` we also define some metadata, using the same `MOVE_CRUD_IT` preprocessor to give comment entities their own CRUD operations.

Under the key node `/aggregates/Article/entities/Comment/properties` we define the properties of comment, which represent the commenter and comment content.

The `Commenter` property is a property of type `String` with a length limit of 100 characters.

The `Body` property is a property of type `String` with a length limit of 500 characters.

### Run dddappp Project Creation Tool

Use Docker to run the project creation tool:

```shell
docker run \
-v /PATH/TO/test:/myapp \
wubuku/dddappp-rooch:0.0.1 \
--dddmlDirectoryPath /myapp/dddml \
--boundedContextName Test.RoochDemo \
--roochMoveProjectDirectoryPath /myapp/move \
--boundedContextRoochPackageName RoochDemo \
--boundedContextRoochNamedAddress rooch_demo \
--boundedContextJavaPackageName org.test.roochdemo \
--javaProjectsDirectoryPath /myapp/rooch-java-service \
--javaProjectNamePrefix roochdemo \
--pomGroupId test.roochdemo
```

The command parameters above are straightforward:

* Note that `/PATH/TO/test` should be replaced with the path of the local directory where you actually place the application code. This line indicates mounting the local directory into the `/myapp` directory inside the container.
* `dddmlDirectoryPath` is the directory where the DDDML model files are located. It should be a directory path that can be read in the container.
* Understand the value of the `boundedContextName` parameter as the name of the application you want to develop. When the name has multiple parts, separate them with dots and use the PascalCase naming convention for each part. Bounded-context is a term in Domain-driven design (DDD) that refers to a specific problem domain scope that contains specific business boundaries, constraints, and language. If you cannot understand this concept for now, it is not a big deal.
* `roochMoveProjectDirectoryPath` is the directory path where the on-chain Rooch contract code is placed. It should be a readable and writable directory path in the container.
* `boundedContextRoochPackageName` is the package name of the on-chain Rooch contract. It is recommended to use PascalCase naming style.
* `boundedContextRoochNamedAddress` is the default named address of the on-chain Rooch contracts. It is recommended to use snake_case naming style.
* `boundedContextJavaPackageName` is the Java package name of the off-chain service. According to Java naming conventions, it should be all lowercase and the parts should be separated by dots.
* `javaProjectsDirectoryPath` is the directory path where the off-chain service code is placed. The off-chain service consists of multiple modules (projects). It should be a readable and writable directory path in the container.
* `javaProjectNamePrefix` is the name prefix of each module of the off-chain service. It is recommended to use an all-lowercase name.
* `pomGroupId` is the Maven GroupId of the off-chain service. We use Maven as the project management tool for off-chain service. It should be all lowercase and the parts should be separated by dots.

After the above command is successfully executed, two directories `move` and `rooch-java-service` should be added to the local directory `/PATH/TO/test`.

### Project Source Code Structure

进入 `move` 目录，这里放置的是从模型生成的 Move 合约项目。执行 Move 编译命令：

```shell
rooch move build --named-addresses rooch_demo={ACCOUNT_ADDRESS}
```

If there are no surprises, the contract project can be built successfully (the last line of the output should show `Success`), but there should be some compilation warnings at this time. That's because some Move source files ending with `_logic.move` have imported (`use`) some modules that are not actually used.

At this point, you can also try to compile the off-chain service. Enter the directory `rooch-java-service` and execute `mvn compile`. If there are no surprises, the compilation should be successful.

#### Contract Project Source Code Structure

In the `move/sources` directory, all the Move source code of the on-chain contract project is included. We first ignore the files ending with `_logic.move` and introduce the other files.

* `rooch_demo_init.move`. It contains the `initialize` function of the on-chain contract. Generally speaking, after the contract project is deployed on-chain, you need to call it first (only need to call it once). However, because our example project is relatively simple, so there is no meaningful initialization logic in the `initialize` function generated by the tool at present, we can ignore it for now.
* `article_aggregate.move`This is where the entry functions are located. Now it contains functions for Create, Update, Delete operations on articles and comments. You can see that the function for creating comments, an internal entity of the aggregate, is named `add_comment` instead of `create_comment`, and the function for deleting comments is named `remove_comment` instead of `delete_comment`. This is actually to make it easier to distinguish these functions as operations on internal entities of the aggregate, rather than operations on the aggregate root itself.
* `article.move`. This file contains the definition of the "data model" of the `Article` aggregate root, as well as the definition of events related to the "article" aggregate.
* `comment.move` This file contains the definition of the "data model" of the `Comment` internal entity of the aggregate.
* The following Move files do not have any complex logic, they just provide some functions that allow you to more conveniently get event property (field) values.
  * `article_created.move`
  * `article_deleted.move`
  * `article_updated.move`
  * `comment_added.move`
  * `comment_removed.move`
  * `comment_updated.move`

#### Business Logic Code

The Move source files ending with `_logic.move` are where the "business logic" implementation code is located.

If you define a method for an aggregate in a DDDML file, then dddappp tool will generate a corresponding Move code file named `{aggregate_name_method_name}_logic.move` for you, and then you need to fill in "business logic" implementation code in this file.

However, we use a preprocessor called `MOVE_CRUD_IT` above to go one step further and automatically generate default implementations for simple CRUD methods. Of course, we can check these "filled-in default logics" and modify them as needed.

After generating a project using the above model, there are already existing "business logic" code files:

* `article_add_comment_logic.move`
* `article_delete_logic.move`
* `article_update_comment_logic.move`
* `article_create_logic.move`
* `article_remove_comment_logic.move`
* `article_update_logic.move`

Now open them and remove those redundant `use` statements. If your IDE has some Move language plugins installed, you may only need to use the "format" feature to reformat these source files.

Then use `rooch move build` command to recompile Move project. Now there should be no warning messages.

## 测试应用

### 运行 Rooch Server 以及发布合约

首先，运行一个本地 Rooch 服务器。

```shell
rooch server start
```

发布 Move 合约：

```shell
rooch move publish --named-addresses rooch_demo={ACCOUNT_ADDRESS}
```

当你看到类似这样的输出（`status` 为 `executed`），就可以确认发布操作已经成功执行了：

```shell
{
  //...
  "execution_info": {
    //...
    "status": {
      "type": "executed"
    }
  },
  //...
}
```

### 使用 CLI 工具测试合约

我们下面将会使用 Rooch CLI 以及其他命令行工具（`curl`、`jq`）来测试已发布的合约。

使用 `rooch move run` 命令提及一个交易，初始化合约（请注意替换占位符 `{ACCOUNT_ADDRESS}` 为你拥有账户的地址）：

```shell
rooch move run --function {ACCOUNT_ADDRESS}::rooch_demo_init::initialize --sender-account {ACCOUNT_ADDRESS}
```

#### CRUD 文章

##### 创建文章

可以像下面这样，使用 Rooch CLI 提交一个交易，创建一篇测试文章：

```shell
rooch move run --function {ACCOUNT_ADDRESS}::article_aggregate::create --sender-account {ACCOUNT_ADDRESS} --args 'string:Hello' 'string:World!'
```

然后你可以更换一下 `--args` 后面的第一个参数（`title`）和第二个参数（`body`）的内容，多创建几篇文章。

##### 查询文章

现在，你可以通过查询事件，得到已创建好的文章的 `ObjectID`：

```shell
curl --location --request POST 'http://localhost:50051' \
--header 'Content-Type: application/json' \
--data-raw '{
 "id":101,
 "jsonrpc":"2.0",
 "method":"rooch_getEventsByEventHandle",
 "params":["{ACCOUNT_ADDRESS}::article::ArticleCreated", null, 1000]
}'
```

你可以在上面的命令最尾添加一个管道操作（` | jq '.result.data[0].parsed_event_data.value.id.value.vec[0]'`），来快速筛选出第一篇文章的 ObjectID。 

> **提示**
>
> 在使用 `jp` 命令（jq - commandline JSON processor）之前，你可能需要在本机上先安装它。

添加 `jp` 处理后的命令像下面这样：

```shell
curl --location --request POST 'http://localhost:50051' \
--header 'Content-Type: application/json' \
--data-raw '{
 "id":101,
 "jsonrpc":"2.0",
 "method":"rooch_getEventsByEventHandle",
 "params":["{ACCOUNT_ADDRESS}::article::ArticleCreated", null, 1000]
}' | jq '.result.data[0].parsed_event_data.value.id.value.vec[0]'
```

然后，你可以使用 Rooch CLI 来查询对象的状态（注意将占位符 `{ARTICLE_OBJECT_ID}` 替换为上面命令得到的文章的 ObjectID）：

```shell
rooch object --id {ARTICLE_OBJECT_ID}
```

##### 更新文章

可以这样提交一个交易，更新文章：

```shell
rooch move run --function {ACCOUNT_ADDRESS}::article_aggregate::update --sender-account {ACCOUNT_ADDRESS} --args 'object_id:{ARTICLE_OBJECT_ID}' 'string:Foo' 'string:Bar'
```

除了使用 Rooch CLI，你还可以通过调用 JSON RPC 来查询对象的状态：

```shell
curl --location --request POST 'http://127.0.0.1:50051/' \
--header 'Content-Type: application/json' \
--data-raw '{
 "id":101,
 "jsonrpc":"2.0",
 "method":"rooch_getAnnotatedStates",
 "params":["/object/{ARTICLE_OBJECT_ID}"]
}'
```

##### 删除文章

可以这样提交一个交易，删除文章：

```shell
rooch move run --function {ACCOUNT_ADDRESS}::article_aggregate::delete --sender-account {ACCOUNT_ADDRESS} --args 'object_id:{ARTICLE_OBJECT_ID}'
```

#### CRUD 评论

##### 添加评论

让我们再获取另一篇文章的 ObjectID（注意下面 `jq` 命令的路径参数 `.result.data[1]`，我们打算获取的是“第二个” `ArticleCreated` 事件的信息）：

```shell
curl --location --request POST 'http://localhost:50051' \
--header 'Content-Type: application/json' \
--data-raw '{
 "id":101,
 "jsonrpc":"2.0",
 "method":"rooch_getEventsByEventHandle",
 "params":["{ACCOUNT_ADDRESS}::article::ArticleCreated", null, 1000]
}' | jq '.result.data[1].parsed_event_data.value.id.value.vec[0]'
```

然后，我们可以使用这个文章的 ID，给它添加一个评论（注意替换占位符 `{ARTICLE_OBJECT_ID}` 为上面获取到的“第二篇”文章的 ObjectID）：

```shell
rooch move run --function {ACCOUNT_ADDRESS}::article_aggregate::add_comment --sender-account {ACCOUNT_ADDRESS} --args 'object_id:{ARTICLE_OBJECT_ID}' 'u64:1' 'string:Anonymous' 'string:"A test comment"'
```

我们可以给这篇文章多添加几条评论，像下面这样执行命令（需要注意修改 `--args` 后面的第二个参数，该参数是评论的序号）：

```shell
rooch move run --function {ACCOUNT_ADDRESS}::article_aggregate::add_comment --sender-account {ACCOUNT_ADDRESS} --args 'object_id:{ARTICLE_OBJECT_ID}' 'u64:2' 'string:Anonymous2' 'string:"A test comment2"'
```

##### 查询评论

在我们的合约代码中，当为一篇文章添加评论时，会 emit 一个 `CommentTableItemAdded` 事件，事件属性包含了当前文章的 ObjectID 以及添加到它的评论表的 key（即 `comment_seq_id`）。

所以，通过查询事件，我们知道一篇文章有那些评论：

```shell
curl --location --request POST 'http://localhost:50051' \
--header 'Content-Type: application/json' \
--data-raw '{
 "id":101,
 "jsonrpc":"2.0",
 "method":"rooch_getEventsByEventHandle",
 "params":["{ACCOUNT_ADDRESS}::article::CommentTableItemAdded", null, 10000]
}' | jq '.result.data[] | select(.parsed_event_data.value.article_id == "{ARTICLE_OBJECT_ID}")'
```

在我们的 Move 合约中，一篇文章的所有评论，是保存在嵌入在该文章对象的一个类型为 `Table<u64, Comment>` 的字段中的。

我们可以通过 JSON RPC 来查询评论的具体信息。获取评论表（comment table）中的项目（item）需要提供两个参数的值：table handle 以及 item key。

首先，我们要取得一篇文章的评论表的 handle：

```shell
curl --location --request POST 'http://127.0.0.1:50051/' \
--header 'Content-Type: application/json' \
--data-raw '{
 "id":101,
 "jsonrpc":"2.0",
 "method":"rooch_getAnnotatedStates",
 "params":["/object/{ARTICLE_OBJECT_ID}"]
}' | jq '.result[0].move_value.value.value.value.comments.value.handle'
```

我们已经知道上面已创建的一条评论的 `comment_seq_id`（即 table 的 item key）是类型为 u64 的整数值 `1`。 

那么，我们可以通过下面的方式获取的评论的具体信息（注意替换下面的占位符 `{COMMENT_TABLE_HANDLE}` 为上面获取到的“评论表”的 handle）：

```shell
curl --location --request POST 'http://127.0.0.1:50051/' \
--header 'Content-Type: application/json' \
--data-raw '{
 "id":101,
 "jsonrpc":"2.0",
 "method":"rooch_getAnnotatedStates",
 "params":["/table/{COMMENT_TABLE_HANDLE}/0x0100000000000000"]
}'
```

注意上面的命令，路径参数中的 table key（在 `{COMMENT_TABLE_HANDLE}/` 之后的那部分），是以十六进制字符串表示的 key 值的 BCS 序列化的结果。

比如，类型为 `u64` 的整数值 `1` 的 BCS 序列化结果，以十六进制字符串表示为 `0x0100000000000000`。

##### 更新评论

我们可以这样提交一个交易，更新评论：

```shell
rooch move run --function {ACCOUNT_ADDRESS}::article_aggregate::update_comment --sender-account {ACCOUNT_ADDRESS} --args 'object_id:{ARTICLE_OBJECT_ID}' 'u64:1' 'string:Anonymous' 'string:"Updated test comment"'
```

然后我们可以再次查询评论的状态，看看评论内容是否已经更新：

```shell
curl --location --request POST 'http://127.0.0.1:50051/' \
--header 'Content-Type: application/json' \
--data-raw '{
 "id":101,
 "jsonrpc":"2.0",
 "method":"rooch_getAnnotatedStates",
 "params":["/table/{COMMENT_TABLE_HANDLE}/0x0100000000000000"]
}'
```

##### 移除评论

提及一个交易，移除评论：

```shell
rooch move run --function {ACCOUNT_ADDRESS}::article_aggregate::remove_comment --sender-account {ACCOUNT_ADDRESS} --args 'object_id:{ARTICLE_OBJECT_ID}' 'u64:1'
```

再次执行上面的 curl 命令查询评论，这次会返回类似这样的信息：

```json
{"jsonrpc":"2.0","result":[null],"id":101}
```

~~因为我们后面这篇文章还有未被删除的评论，所以如果现在想要删除它，应该不会成功。尝试执行~~：

```shell
rooch move run --function {ACCOUNT_ADDRESS}::article_aggregate::delete --sender-account {ACCOUNT_ADDRESS} --args 'object_id:{ARTICLE_OBJECT_ID}'
```

返回的交易执行状态应该是失败的：

```json
//[TBD]
```

### One more thing

如果你有兴趣，可以参考 ["A Rooch Demo"](https://github.com/dddappp/A-Rooch-Demo#configure-off-chain-service) 的介绍，配置目录 `rooch-java-service` 下的 Java 链下服务，然后将服务运行起来。

通过查询链下服务的 RESTful API，你可以更容易地查询到文件和评论的具体信息，而不需要使用上面介绍的 curl 和 jp 命令。

